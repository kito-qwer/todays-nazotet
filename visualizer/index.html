<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NazoTet Visualizer</title>
    <link href="../style.css" rel="stylesheet">
    <style>
        body {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        #visualizer-wrapper {
            overflow: auto;
            max-width: 100%;
        }
        #visualizer {
            width: 440px;
            height: 560px;
        }
    </style>
</head>

<body class="bg-white dark:bg-black text-gray-800 dark:text-white transition-colors duration-300">
    <div class="visualizer mx-auto max-w-2xl p-4 sm:p-8">
        <header class="mb-8 text-center">
            <h1 class="text-3xl sm:text-4xl font-bold text-yellow-400">NazoTet Visualizer</h1>
        </header>

        <main class="space-y-6">

            <div class="space-y-4">
                <div>
                    <label for="fumen" class="block mb-2 text-sm font-medium">Fumen</label>
                    <input type="text" id="fumen" name="fumen_string"
                        class="h-10 w-full p-2.5 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                        placeholder="v115@...">
                </div>
                <div>
                    <label for="next" class="block mb-2 text-sm font-medium">Next Mino</label>
                    <input type="text" id="next" name="next_string"
                        class="h-10 w-full p-2.5 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                        placeholder="TISZ...">
                </div>
                <div>
                    <label for="hold" class="block mb-2 text-sm font-medium">Hold Mino</label>
                    <input type="text" id="hold" name="hold_string"
                        class="h-10 w-full p-2.5 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                        placeholder="Initial hold (If hold is unavailable, fill in 'X')">
                </div>
                <div>
                    <label for="author" class="block mb-2 text-sm font-medium">Author</label>
                    <input type="text" id="author" name="author_string"
                        class="h-10 w-full p-2.5 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                        placeholder="Your name">
                </div>
            </div>

            <fieldset class="border border-gray-600 p-4">
                <legend class="text-sm font-medium px-2">Rules</legend>
                <div class="grid grid-cols-2 sm:grid-cols-3 gap-4 mt-2">
                    <div>
                        <label for="tss" class="block mb-1 text-xs font-medium">TSS</label>
                        <input type="number" id="tss" name="tss_count"
                            class="h-10 w-full p-2 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                            placeholder="0" min="0">
                    </div>
                    <div>
                        <label for="tsd" class="block mb-1 text-xs font-medium">TSD</label>
                        <input type="number" id="tsd" name="tsd_count"
                            class="h-10 w-full p-2 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                            placeholder="0" min="0">
                    </div>
                    <div>
                        <label for="tst" class="block mb-1 text-xs font-medium">TST</label>
                        <input type="number" id="tst" name="tst_count"
                            class="h-10 w-full p-2 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                            placeholder="0" min="0">
                    </div>
                    <div>
                        <label for="tssm" class="block mb-1 text-xs font-medium">Mini TSS</label>
                        <input type="number" id="tssm" name="mini_tss_count"
                            class="h-10 w-full p-2 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                            placeholder="0" min="0">
                    </div>
                    <div>
                        <label for="tsdm" class="block mb-1 text-xs font-medium">Mini TSD</label>
                        <input type="number" id="tsdm" name="mini_tsd_count"
                            class="h-10 w-full p-2 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                            placeholder="0" min="0">
                    </div>
                    <div>
                        <label for="quad" class="block mb-1 text-xs font-medium">Quad</label>
                        <input type="number" id="quad" name="quad_count"
                            class="h-10 w-full p-2 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                            placeholder="0" min="0">
                    </div>
                    <div class="col-span-2 sm:col-span-3">
                        <label for="pc" class="block mb-1 text-xs font-medium">Perfect Clear</label>
                        <input type="number" id="pc" name="pc_count"
                            class="h-10 w-full p-2 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                            placeholder="0" min="0">
                    </div>
                    <div class="col-span-2 sm:col-span-3">
                        <label for="otherRules" class="block mb-1 text-xs font-medium">Other Rules</label>
                        <textarea id="otherRules" name="otherRules"
                            class="w-full p-2 bg-gray-50 border border-gray-600 text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 block dark:bg-gray-800 dark:border-gray-600 dark:placeholder-gray-300 dark:text-white"
                            placeholder="Combos: 3&#10;Back-to-Back: 2" rows="2"></textarea>
                    </div>
                </div>
            </fieldset>

            <div class="text-center pt-4">
                <button id="visualizeButton"
                    class="h-10 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 transition-colors">
                    Visualize
                </button>
                <button id="downloadButton"
                    class="h-10 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 transition-colors">
                    Image Download (svg)
                </button>
                <button id="downloadButtonPng"
                    class="h-10 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 transition-colors">
                    Image Download (png)
                </button>
            </div>
    </div>
    <div class="flex justify-center bg-gray-200">
        <div id="visualizer-wrapper" class="p-10">
            <div id="visualizer"></div>
        </div>
    </div>
    </main>

    </footer>
    </div>
    <script src="../scripts/fumen-parser.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const visualizeButton = document.getElementById('visualizeButton');
            const downloadButton = document.getElementById('downloadButton');
            const downloadButtonPng = document.getElementById('downloadButtonPng');

            const COLS = Tetfu.FIELD_WIDTH;
            const ROWS = Tetfu.FIELD_HEIGHT - 1;
            const CELL_SIZE = 20;

            let field = Array(240).fill(0);
            let nextQueue = '';
            let holdPiece = '';
            let activeRules = [];
            let author = '';
            let otherRules = [];

            const visualizer = document.getElementById('visualizer');

            // 描画
            function calculateDynamicFontSize(text, initialSize, maxWidth, fontFamily) {
                if (typeof document === 'undefined') {
                    // Node.jsなどdocumentがない環境では、計算を行わず初期サイズを返す
                    return initialSize;
                }
                // 一時的な非表示Canvasを作成してテキスト幅を測定
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.font = `${initialSize}px ${fontFamily}`;
                const textMetrics = ctx.measureText(text);

                if (textMetrics.width > maxWidth) {
                    // 幅が最大値を超えていたら、比率でフォントサイズを縮小する
                    return initialSize * (maxWidth / textMetrics.width);
                }
                return initialSize;
            }

            function draw() {

                const width = visualizer.clientWidth;
                const height = visualizer.clientHeight;

                // --- 定数定義 ---
                const CANVAS_PADDING_LEFT_IN_CELLS = 6;
                const FIELD_BUFFER_ZONE_HEIGHT = 3;

                const PIECE_AREA_WIDTH_IN_CELLS = 4;
                const PIECE_AREA_HEIGHT_IN_CELLS = 3;
                const PIECE_AREA_MARGIN_IN_CELLS = 1;
                const AREA_LABEL_OFFSET_Y = 5;
                const AREA_BOX_PADDING_X = 5;

                const NEXT_PIECES_TO_DRAW_COUNT = 6;
                const NEXT_PIECE_VERTICAL_GAP_IN_CELLS = 0.5;
                const NEXT_TEXT_CHARS_PER_LINE = 8;
                const NEXT_TEXT_LINE_HEIGHT = 20;

                const FONT_FAMILY_MONO = 'ui-monospace, "SF Mono", "Menlo", "Consolas", "Liberation Mono", "Courier New", monospace';
                const LABEL_FONT_FAMILY = FONT_FAMILY_MONO;
                const MESSAGE_FONT_FAMILY = FONT_FAMILY_MONO;
                const AUTHOR_RULES_FONT_FAMILY = FONT_FAMILY_MONO;
                const CREDIT_FONT_FAMILY = FONT_FAMILY_MONO;

                // --- 座標・サイズ計算 ---
                const startX = CELL_SIZE * CANVAS_PADDING_LEFT_IN_CELLS;
                const startY = (height - ROWS * CELL_SIZE) / 2;
                const endX = startX + COLS * CELL_SIZE;
                const endY = startY + ROWS * CELL_SIZE;

                const areaWidth = CELL_SIZE * PIECE_AREA_WIDTH_IN_CELLS;
                const areaHeight = CELL_SIZE * PIECE_AREA_HEIGHT_IN_CELLS;
                const holdAreaX = startX - (PIECE_AREA_WIDTH_IN_CELLS + PIECE_AREA_MARGIN_IN_CELLS) * CELL_SIZE;
                const holdAreaY = startY;
                const nextAreaX = endX + PIECE_AREA_MARGIN_IN_CELLS * CELL_SIZE;
                const nextAreaY = startY;

                // --- データ定義 ---
                const blockColors = { 0: 'black', 1: 'aqua', 2: 'orange', 3: 'yellow', 4: 'red', 5: 'fuchsia', 6: 'blue', 7: 'lime', 8: 'silver' };
                const blockShapes = { 1: [[1, 1, 1, 1]], 2: [[0, 0, 1], [1, 1, 1]], 3: [[1, 1], [1, 1]], 4: [[1, 1, 0], [0, 1, 1]], 5: [[0, 1, 0], [1, 1, 1]], 6: [[1, 0, 0], [1, 1, 1]], 7: [[0, 1, 1], [1, 1, 0]] };
                const pieceTypeMap = { 'I': 1, 'L': 2, 'O': 3, 'Z': 4, 'T': 5, 'J': 6, 'S': 7, 'X': -1 };

                // SVG要素を格納する配列
                const svgElements = [];

                const drawPieceSVG = (pieceId, areaX, areaY) => {
                    if (!pieceId || pieceId < 1) return '';
                    const shape = blockShapes[pieceId];
                    const color = blockColors[pieceId];
                    const pieceWidth = shape[0].length;
                    const pieceHeight = shape.length;
                    const offsetX = areaX + (CELL_SIZE * PIECE_AREA_WIDTH_IN_CELLS - pieceWidth * CELL_SIZE) / 2;
                    const offsetY = areaY + (CELL_SIZE * PIECE_AREA_HEIGHT_IN_CELLS - pieceHeight * CELL_SIZE) / 2;

                    let pieceSVG = '';
                    for (let y = 0; y < pieceHeight; y++) {
                        for (let x = 0; x < pieceWidth; x++) {
                            if (shape[y][x]) {
                                pieceSVG += `<rect x="${offsetX + x * CELL_SIZE}" y="${offsetY + y * CELL_SIZE}" width="${CELL_SIZE}" height="${CELL_SIZE}" fill="${color}" />\n`;
                            }
                        }
                    }
                    return pieceSVG;
                };

                // --- SVG描画開始 ---

                // 全体の背景
                svgElements.push(`<rect x="0" y="0" width="${width}" height="${height}" fill="#ffffff" />`);

                // フィールド背景
                svgElements.push(`<rect x="${startX}" y="${startY}" width="${COLS * CELL_SIZE}" height="${ROWS * CELL_SIZE}" fill="black" />`);

                // フィールド内のブロックを描画
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        const blockValue = field[y * COLS + x];
                        let color = blockColors[blockValue] || 'dimgray';
                        if (y < FIELD_BUFFER_ZONE_HEIGHT && blockValue == 0) {
                            color = 'dimgray';
                        }
                        svgElements.push(`<rect x="${startX + x * CELL_SIZE}" y="${startY + y * CELL_SIZE}" width="${CELL_SIZE}" height="${CELL_SIZE}" fill="${color}" />`);
                    }
                }

                // グリッド線の描画（<path>で一括描画）
                let pathData = '';
                for (let x = 0; x <= COLS; x++) { const currentX = startX + x * CELL_SIZE; pathData += `M${currentX},${startY} L${currentX},${endY} `; }
                for (let y = 0; y <= ROWS; y++) { const currentY = startY + y * CELL_SIZE; pathData += `M${startX},${currentY} L${endX},${currentY} `; }
                svgElements.push(`<path d="${pathData}" stroke="dimgray" stroke-width="1" fill="none" />`);

                // --- HOLD描画 ---
                svgElements.push(`<text x="${holdAreaX}" y="${holdAreaY - AREA_LABEL_OFFSET_Y}" font-family='${LABEL_FONT_FAMILY}' font-size="16px" fill="black" text-anchor="start" dominant-baseline="alphabetic">HOLD</text>`);
                svgElements.push(`<rect x="${holdAreaX - AREA_BOX_PADDING_X}" y="${holdAreaY}" width="${areaWidth + AREA_BOX_PADDING_X * 2}" height="${areaHeight}" fill="silver" />`);

                let holdMessage = 'Available';
                if (holdPiece) {
                    const pieceId = pieceTypeMap[holdPiece];
                    if (pieceId > 0) {
                        holdMessage = '';
                        svgElements.push(drawPieceSVG(pieceId, holdAreaX, holdAreaY));
                    } else if (pieceId === -1) {
                        holdMessage = 'Unavailable';
                    }
                }
                if (holdMessage) {
                    const textX = holdAreaX + areaWidth / 2;
                    const textY = holdAreaY + areaHeight / 2;
                    svgElements.push(`<text x="${textX}" y="${textY}" font-family='${MESSAGE_FONT_FAMILY}' font-size="13px" fill="black" text-anchor="middle" dominant-baseline="middle">${holdMessage}</text>`);
                }

                // --- NEXT描画 ---
                svgElements.push(`<text x="${nextAreaX}" y="${nextAreaY - AREA_LABEL_OFFSET_Y}" font-family='${LABEL_FONT_FAMILY}' font-size="16px" fill="black" text-anchor="start" dominant-baseline="alphabetic">NEXT</text>`);
                if (nextQueue) {
                    const piecesToDraw = Math.min(nextQueue.length, NEXT_PIECES_TO_DRAW_COUNT);
                    for (let i = 0; i < piecesToDraw; i++) {
                        const currentY = nextAreaY + i * (areaHeight + CELL_SIZE * NEXT_PIECE_VERTICAL_GAP_IN_CELLS);
                        svgElements.push(`<rect x="${nextAreaX - AREA_BOX_PADDING_X}" y="${currentY}" width="${areaWidth + AREA_BOX_PADDING_X * 2}" height="${areaHeight}" fill="silver" />`);
                        const pieceId = pieceTypeMap[nextQueue[i]];
                        svgElements.push(drawPieceSVG(pieceId, nextAreaX, currentY));
                    }
                    const remainingQueue = nextQueue.slice(NEXT_PIECES_TO_DRAW_COUNT);
                    if (remainingQueue) {
                        let textY = nextAreaY + NEXT_PIECES_TO_DRAW_COUNT * (areaHeight + CELL_SIZE * NEXT_PIECE_VERTICAL_GAP_IN_CELLS) + 12;
                        for (let i = 0; i < remainingQueue.length; i += NEXT_TEXT_CHARS_PER_LINE) {
                            const line = remainingQueue.substring(i, i + NEXT_TEXT_CHARS_PER_LINE);
                            svgElements.push(`<text x="${nextAreaX - 4}" y="${textY}" font-family='${LABEL_FONT_FAMILY}' font-size="16px" fill="black">→</text>`);
                            svgElements.push(`<text x="${nextAreaX + 10}" y="${textY}" font-family='${LABEL_FONT_FAMILY}' font-size="16px" fill="black">${line}</text>`);
                            textY += NEXT_TEXT_LINE_HEIGHT;
                        }
                    }
                }

                // --- Author & Rules描画 ---
                {
                    let currentY = holdAreaY + areaHeight + 20;
                    const lineHeight = 20;
                    const indent = 5;

                    if (author) {
                        svgElements.push(`<text x="${holdAreaX}" y="${currentY}" font-family='${AUTHOR_RULES_FONT_FAMILY}' font-size="14px" fill="black">Author</text>`);
                        currentY += lineHeight;

                        // 動的フォントサイズを計算
                        const initialFontSize = 14;
                        const maxWidth = areaWidth - indent;
                        const authorFontSize = calculateDynamicFontSize(author, initialFontSize, maxWidth, AUTHOR_RULES_FONT_FAMILY);

                        // 計算されたフォントサイズを適用
                        svgElements.push(`<text x="${holdAreaX + indent}" y="${currentY}" font-family='${AUTHOR_RULES_FONT_FAMILY}' font-size="${authorFontSize.toFixed(2)}px" fill="black">${author}</text>`);
                        currentY += lineHeight;
                    }

                    if (activeRules.length > 0 || otherRules.length > 0) {
                        svgElements.push(`<text x="${holdAreaX}" y="${currentY}" font-family='${AUTHOR_RULES_FONT_FAMILY}' font-size="14px" fill="black">Rules</text>`);
                        currentY += lineHeight;

                        activeRules.forEach(([ruleName, count]) => {
                            svgElements.push(`<text x="${holdAreaX + indent}" y="${currentY}" font-family='${AUTHOR_RULES_FONT_FAMILY}' font-size="14px" fill="black">${ruleName}: ${count}</text>`);
                            currentY += lineHeight;
                        });
                        otherRules.forEach(rule => {
                            svgElements.push(`<text x="${holdAreaX + indent}" y="${currentY}" font-family='${AUTHOR_RULES_FONT_FAMILY}' font-size="14px" fill="black">${rule}</text>`);
                            currentY += lineHeight;
                        });
                    }
                }

                // --- 右下のクレジット表示 ---
                const padding = 5;
                const attribution = 'This image was generated by NazoTet Visualizer.';
                svgElements.push(`<text x="${width - padding}" y="${height - padding}" font-family='${CREDIT_FONT_FAMILY}' font-size="10px" fill="gray" text-anchor="end" dominant-baseline="alphabetic">${attribution}</text>`);

                // --- 最終的なSVG文字列を組み立てる ---
                const svgString = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" style="background-color: #ffffff;">\n${svgElements.join('\n')}\n</svg>`;
                visualizer.innerHTML = svgString;
            }

            draw();

            visualizeButton.addEventListener('click', () => {
                const formData = {
                    fumen: document.getElementById('fumen').value,
                    next: document.getElementById('next').value,
                    hold: document.getElementById('hold').value,
                    author: document.getElementById('author').value,
                    rules: {
                        TSS: parseInt(document.getElementById('tss').value, 10) || 0,
                        TSD: parseInt(document.getElementById('tsd').value, 10) || 0,
                        TST: parseInt(document.getElementById('tst').value, 10) || 0,
                        miniTSS: parseInt(document.getElementById('tssm').value, 10) || 0,
                        miniTSD: parseInt(document.getElementById('tsdm').value, 10) || 0,
                        QUAD: parseInt(document.getElementById('quad').value, 10) || 0,
                        PC: parseInt(document.getElementById('pc').value, 10) || 0,
                    },
                    otherRules: document.getElementById('otherRules').value,
                };


                const decodedFumen = Tetfu.Fumen.decode(formData.fumen);
                if (decodedFumen && decodedFumen.getPages().length > 0) {
                    const firstPage = decodedFumen.getPages()[0];
                    field = firstPage.field;
                    const comment = firstPage.flags.comment || "";

                    if (formData.next === "") {
                        const nextMatch = comment.match(/^#Q=\[[ILOZTJS]?\]\(([ILOZTJS])\)([ILOZTJS]*)/);
                        if (nextMatch) {
                            formData.next = nextMatch[1] + nextMatch[2];
                        }
                    }
                    if (formData.hold === "") {
                        const holdMatch = comment.match(/^#Q=\[([ILOZTJS])\]\([ILOZTJS]\)[ILOZTJS]/);
                        if (holdMatch) {
                            formData.hold = holdMatch[1];
                        }
                    }
                }

                if (/^[ILOZTJS]+$/i.test(formData.next)) {
                    nextQueue = formData.next.toUpperCase();
                    document.getElementById('next').value = nextQueue;
                } else {
                    nextQueue = '';
                }
                if (/^[ILOZTJSX]$/i.test(formData.hold)) {
                    holdPiece = formData.hold.toUpperCase();
                    document.getElementById('hold').value = holdPiece;
                } else {
                    holdPiece = '';
                }
                author = formData.author;
                activeRules = Object.entries(formData.rules).filter(([, count]) => count > 0);

                otherRules = formData.otherRules ? formData.otherRules.split('\n').filter(line => line.trim() !== '') : [];

                draw();
            });

            downloadButton.addEventListener('click', () => {
                const svgString = visualizer.innerHTML;

                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));

                const link = document.createElement('a');
                link.href = dataUrl;

                const now = new Date();
                const timestamp = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;

                link.download = `nazotet_${timestamp}.svg`;

                link.click();
            });
            
            downloadButtonPng.addEventListener('click', () => {
                const visualizer = document.getElementById('visualizer');
                const svgString = visualizer.innerHTML;

                const width = visualizer.clientWidth;
                const height = visualizer.clientHeight;

                const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));

                const img = new Image();

                img.onload = () => {
                    const scale = 2;

                    const canvas = document.createElement('canvas');
                    canvas.width = width * scale;
                    canvas.height = height * scale;

                    const ctx = canvas.getContext('2d');
                    ctx.scale(scale, scale);

                    ctx.drawImage(img, 0, 0);

                    const pngDataUrl = canvas.toDataURL('image/png');

                    const link = document.createElement('a');
                    link.href = pngDataUrl;

                    const now = new Date();
                    const timestamp = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;

                    link.download = `nazotet_${timestamp}.png`;
                    link.click();
                };

                img.src = svgDataUrl;
            });

            // 初期描画
            draw();
        });
    </script>
</body>

</html>